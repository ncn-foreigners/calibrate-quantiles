% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint_calib.R
\name{joint_calib}
\alias{joint_calib}
\title{Function to calibrate totals and quantiles jointly}
\usage{
joint_calib(
  formula_totals = NULL,
  formula_quantiles = NULL,
  data = NULL,
  design = NULL,
  dweights = NULL,
  N = NULL,
  pop_totals = NULL,
  pop_quantiles = NULL,
  subset = NULL,
  bounds = c(0, 10),
  maxit = 50,
  tol = 1e-08,
  backend = c("sampling", "laeken", "survey"),
  method = c("raking", "linear", "logit", "sinh"),
  control = list(interpolation = "linear", logit_const = -1000),
  ...
)
}
\arguments{
\item{formula_totals}{a formula with variables for calibration of totals}

\item{formula_quantiles}{a formula with variables for calibration of quantiles}

\item{data}{a data.frame with variables}

\item{design}{a svydesign object (currently not supported)}

\item{dweights}{initial d-weights for calibration (e.g. design-weights)}

\item{N}{population size for calibration of quantiles}

\item{pop_totals}{a named vector of population totals for \code{X}, should be provided exactly as in \code{survey} package (see \code{survey::calibrate})}

\item{pop_quantiles}{a named list of of population quantiles for \code{X_q}}

\item{subset}{a formula for subset of data}

\item{bounds}{a numeric vector of length two giving bounds for the g-weights}

\item{maxit}{a numeric value giving the maximum number of iterations}

\item{tol}{the desired accuracy for the iterative procedure (for \code{sampling} and \code{laeken}) or Tolerance in matching population total for \code{survey::grake} (see help for survey::grake)}

\item{backend}{specify an R package to perform calibration}

\item{method}{specify distance function for calibration}

\item{control}{a list of control parameters (currently not supported)}

\item{...}{arguments passed either to \code{sampling::calib}, \code{laeken::calibWeights} or \code{survey::calibrate}}
}
\value{
Returns a list with containing:\cr
\itemize{
\item{\code{g} -- g-weight}
\item{\code{Xs} -- matrix used for calibration (i.e. Intercept, X and X_q transformed for calibration of quantiles)}
\item{\code{totals} -- a vector of totals (i.e. \code{N}, \code{pop_totals} and \code{pop_quantiles})}
\item{\code{diff} -- difference between \code{colSums(Xs*w)} and \code{totals}}
}
}
\description{
\code{joint_calib} allows to specify matrix of X variables for calibration of totals (intercept should not be included) and matrix of X_q variables for calibration of quantiles.
}
\examples{
\donttest{
## generate data based on Haziza and Lesage (2016)
set.seed(123)
N <- 1000
x <- runif(N, 0, 80)
y <- exp(-0.1 + 0.1*x) + rnorm(N, 0, 300)
p <- rbinom(N, 1, prob = exp(-0.2 - 0.014*x))
probs <- seq(0.1, 0.9, 0.1)
quants_known <- list(x=quantile(x, probs))
totals_known <- c(x=sum(x))
df <- data.frame(x, y, p)
df_resp <- df[df$p == 1, ]
df_resp$d <- N/nrow(df_resp)
y_quant_true <- quantile(y, probs)
## standard calibration for comparison
result0 <- sampling::calib(Xs = cbind(1, df_resp$x),
                           d = df_resp$d,
                           total = c(N, totals_known),
                           method = "linear")

y_quant_hat0 <- laeken::weightedQuantile(x = df_resp$y,
                                         probs = probs,
                                         weights = result0*df_resp$d)
x_quant_hat0 <- laeken::weightedQuantile(x = df_resp$x,
                                         probs = probs,
                                         weights = result0*df_resp$d)

## example 1: calibrate only quantiles (deciles)
result1 <- joint_calib(formula_quantiles = ~x,
                       data = df_resp,
                       dweights = df_resp$d,
                       N = N,
                       pop_quantiles = quants_known,
                       method = "linear",
                       backend = "sampling")
## estimate quantiles
y_quant_hat1 <- laeken::weightedQuantile(x = df_resp$y,
                                         probs = probs,
                                         weights = result1$g*df_resp$d)
x_quant_hat1 <- laeken::weightedQuantile(x = df_resp$x,
                                         probs = probs,
                                         weights = result1$g*df_resp$d)

## compare with known
data.frame(standard = y_quant_hat0, est=y_quant_hat1, true=y_quant_true)

## example 2: calibrate with quantiles (deciles) and totals
result2 <- joint_calib(formula_totals = ~x,
                       formula_quantiles = ~x,
                       data = df_resp,
                       dweights = df_resp$d,
                       N = N,
                       pop_quantiles = quants_known,
                       pop_totals = totals_known,
                       method = "linear",
                       backend = "sampling")
## estimate quantiles
y_quant_hat2 <- laeken::weightedQuantile(x = df_resp$y,
                                         probs = probs,
                                         weights = result2$g*df_resp$d)
x_quant_hat2 <- laeken::weightedQuantile(x = df_resp$x,
                                         probs = probs,
                                         weights = result2$g*df_resp$d)

## compare with known
data.frame(standard = y_quant_hat0, est1=y_quant_hat1,
           est2=y_quant_hat2, true=y_quant_true)

## example 3: calibrate wigh quantiles (deciles) and totals with
## hyperbolic sinus (sinh) and survey package

result3 <- joint_calib(formula_totals = ~x,
                       formula_quantiles = ~x,
                       data = df_resp,
                       dweights = df_resp$d,
                       N = N,
                       pop_quantiles = quants_known,
                       pop_totals = totals_known,
                       method = "sinh",
                       backend = "survey")

## estimate quantiles
y_quant_hat3 <- laeken::weightedQuantile(x = df_resp$y,
                                         probs = probs,
                                         weights = result3$g*df_resp$d)
x_quant_hat3 <- laeken::weightedQuantile(x = df_resp$x,
                                         probs = probs,
                                         weights = result3$g*df_resp$d)

## compare with known
data.frame(standard = y_quant_hat0, est1=y_quant_hat1,
           est2=y_quant_hat2, est3=y_quant_hat3, true=y_quant_true)
## compare with known X
data.frame(standard = x_quant_hat0, est1=x_quant_hat1,
           est2=x_quant_hat2, est3=x_quant_hat3, true = quants_known$x)

}
}
\references{
Deville, J. C., and Särndal, C. E. (1992). Calibration estimators in survey sampling.
Journal of the American statistical Association, 87(418), 376-382.

Harms, T. and Duchesne, P. (2006). On calibration estimation for quantiles.
Survey Methodology, 32(1), 37.

Haziza, D., and Lesage, É. (2016). A discussion of weighting procedures for unit nonresponse. Journal of Official Statistics, 32(1), 129-145.
}
\seealso{
\code{\link[sampling:calib]{sampling::calib()}} -- for standard calibration.
\code{\link[laeken:calibWeights]{laeken::calibWeights()}} -- for standard calibration.
\code{\link[survey:calibrate]{survey::calibrate()}} -- for standard and more advanced calibration.
}
\author{
Maciej Beręsewicz
}
