[{"path":"https://ncn-foreigners.github.io/jointCalib/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maciej Beręsewicz. Author, maintainer.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Beręsewicz M (2023). jointCalib: Joint Calibration Totals Quantiles. https://github.com/ncn-foreigners/jointCalib, https://ncn-foreigners.github.io/jointCalib/.","code":"@Manual{,   title = {jointCalib: A Joint Calibration of Totals and Quantiles},   author = {Maciej Beręsewicz},   year = {2023},   note = {https://github.com/ncn-foreigners/jointCalib, https://ncn-foreigners.github.io/jointCalib/}, }"},{"path":[]},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"details","dir":"","previous_headings":"","what":"Details","title":"A Joint Calibration of Totals and Quantiles","text":"small package joint calibration totals quantiles (see Beręsewicz Szymkowiak (2023) working paper details). package combines following approaches: Deville, J. C., Särndal, C. E. (1992). Calibration estimators survey sampling. Journal American statistical Association, 87(418), 376-382. Harms, T. Duchesne, P. (2006). calibration estimation quantiles. Survey Methodology, 32(1), 37. Wu, C. (2005) Algorithms R codes pseudo empirical likelihood method survey sampling, Survey Methodology, 31(2), 239. Zhang, S., Han, P., Wu, C. (2023) Calibration Techniques Encompassing Survey Sampling, Missing Data Analysis Causal Inference, International Statistical Review 91, 165–192. allows calibrate weights known (estimated) totals quantiles jointly. backend calibration sampling (sampling::calib), laeken (laeken::calibWeights), survey (survey::grake) ebal (ebal::eb) package can used. One can also apply empirical likelihood using codes Wu (2005) support stats::constrOptim used Zhang, Han Wu (2022). Currently supports: calibration quantiles, calibration quantiles totals, calibration using standard calibration, empirical likelihood entropy balancing method. plans: generalized calibration via sampling::gencalib, calibrated / covariate balancing propensity score (see causal branch initial development), calibration Gini metrics, observational studies / causal inference (see causal branch initial development) …","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"A Joint Calibration of Totals and Quantiles","text":"Work package supported National Science Centre, OPUS 22 grant . 2020/39/B/HS4/00941.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Joint Calibration of Totals and Quantiles","text":"can install development version jointCalib GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"ncn-foreigners/jointCalib\")"},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"A Joint Calibration of Totals and Quantiles","text":"Load packages","code":"library(jointCalib) library(survey) library(laeken) library(ebal)"},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"example-1--census-case","dir":"","previous_headings":"Examples","what":"Example 1 – census case","title":"A Joint Calibration of Totals and Quantiles","text":"Based Haziza, D., Lesage, É. (2016). discussion weighting procedures unit nonresponse. Journal Official Statistics, 32(1), 129-145.","code":"set.seed(20230817) N <- 1000 x <- runif(N, 0, 80) #y <- 1000+10*x+rnorm(N, 0, 300) #y <- exp(-0.1 + 0.1*x) + rnorm(N, 0, 300) #y <- rbinom(N, 1, prob = 1/(exp(-0.5*(x-55))+1)) y <- 1300-(x-40)^2 + rnorm(N, 0, 300) #p <- rbinom(N, 1, prob = 0.2+0.6*(1 + exp(-5 + x/8))^-1) p <- rbinom(N, 1, prob = 0.07+0.45*(x/40-1)^2+0.0025*x) #p <- rbinom(N, 1, prob = (1.2+0.024*x)^-1) #p <- rbinom(N, 1, prob = exp(-0.2 - 0.014*x)) probs <- seq(0.1, 0.9, 0.1) quants_known <- list(x=quantile(x, probs)) totals_known <- c(x=sum(x)) df <- data.frame(x, y, p) df_resp <- df[df$p == 1, ] df_resp$d <- N/nrow(df_resp) y_quant_true <- quantile(y, probs) head(df_resp) #>           x        y p        d #> 6  12.35687 444.9053 1 3.134796 #> 7  61.90319 403.9473 1 3.134796 #> 13 60.96079 923.4975 1 3.134796 #> 14 76.85300 124.4110 1 3.134796 #> 18 71.52828 422.0934 1 3.134796 #> 19 65.32808 740.4801 1 3.134796"},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"using-jointcalib-package","dir":"","previous_headings":"Examples","what":"Using jointCalib package","title":"A Joint Calibration of Totals and Quantiles","text":"example 1a: calibrate quantiles (deciles) example 1b: calibrate quantiles (deciles) can restrict weights specific range using logit. Empirical likelihood method can applied using following code Entropy balancing method can applied using following code Finally, compare method true Y distribution est_y1 – weights calibrated quantiles , est_y2 – weights calibrated quantiles totals, est_y3 – weights calibrated quantiles totals using logit distance range limitations, est_y4 – weights calibrated means using el. est_y5 – weights calibrated quantiles using el. est_y6 – weights calibrated quantiles totals using el. est_y7 – weights calibrated quantiles totals using eb. sum squares calibration totals means seems best.","code":"result1 <- joint_calib(formula_quantiles = ~x,                       data=df_resp,                       dweights=df_resp$d,                       N = N,                       pop_quantiles = quants_known,                       method = \"linear\",                       backend = \"sampling\") result1 #> Weights calibrated using: linear with sampling backend. #> Summary statistics for g-weights: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.4562  0.6773  0.8180  1.0000  1.4500  2.4538  #> Totals and precision (abs diff: 4.574665e-10) #>       totals    precision #>  [1,]  1e+03 4.557705e-10 #>  [2,]  1e-01 5.020984e-14 #>  [3,]  2e-01 1.055545e-13 #>  [4,]  3e-01 1.324496e-13 #>  [5,]  4e-01 1.580958e-13 #>  [6,]  5e-01 1.765255e-13 #>  [7,]  6e-01 1.991740e-13 #>  [8,]  7e-01 2.304823e-13 #>  [9,]  8e-01 2.882139e-13 #> [10,]  9e-01 3.552714e-13 data.frame(true = quants_known$x, est = weightedQuantile(df_resp$x, result1$g*df_resp$d, probs)) #>          true       est #> 10%  7.078067  7.085003 #> 20% 14.831221 14.824424 #> 30% 23.146180 23.287657 #> 40% 31.641911 31.802986 #> 50% 39.033812 39.154276 #> 60% 47.527168 48.252065 #> 70% 54.984229 55.311953 #> 80% 64.073167 64.062629 #> 90% 71.565441 71.567274 result2 <- joint_calib(formula_totals = ~x,                        formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        pop_totals = totals_known,                        method = \"linear\",                        backend = \"sampling\") summary(result2$g) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.3563  0.6208  0.8199  1.0000  1.4368  2.5384 data.frame(true = quants_known$x, est = weightedQuantile(df_resp$x, result2$g*df_resp$d, probs)) #>          true       est #> 10%  7.078067  7.085003 #> 20% 14.831221 14.824424 #> 30% 23.146180 23.287657 #> 40% 31.641911 31.802986 #> 50% 39.033812 39.154276 #> 60% 47.527168 48.252065 #> 70% 54.984229 55.311953 #> 80% 64.073167 64.062629 #> 90% 71.565441 71.567274 result3 <- joint_calib(formula_totals = ~x,                        formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        pop_totals = totals_known,                        method = \"logit\",                        backend = \"sampling\",                         maxit = 500,                        bounds = c(0, 3))  summary(result3$g) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.3911  0.6254  0.8140  1.0000  1.4325  2.5186 data.frame(true = quants_known$x, est = weightedQuantile(df_resp$x, result3$g*df_resp$d, probs)) #>          true       est #> 10%  7.078067  7.085003 #> 20% 14.831221 14.824424 #> 30% 23.146180 22.872078 #> 40% 31.641911 31.297922 #> 50% 39.033812 39.154276 #> 60% 47.527168 48.252065 #> 70% 54.984229 55.311953 #> 80% 64.073167 64.529683 #> 90% 71.565441 71.567274 result4a <- joint_calib(formula_quantiles = ~ x,                         data = df_resp,                         dweights = df_resp$d,                         N = N,                         pop_quantiles = quants_known,                         method = \"el\",                         backend = \"base\") summary(result4a$g) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.4563  0.6773  0.8180  1.0000  1.4500  2.4538  result4b <- joint_calib(formula_totals = ~ x,                         formula_quantiles = ~ x,                         data = df_resp,                         dweights = df_resp$d,                         N = N,                         pop_quantiles = quants_known,                         pop_totals = totals_known,                         method = \"el\",                         backend = \"base\")  summary(result4b$g) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.4414  0.6584  0.8109  1.0000  1.4256  2.8513  result4c <- calib_el(X = result4b$Xs[, c(1, 11)],                      d = df_resp$d,                       totals = c(N,totals_known),                      maxit = 50,                      tol = 1e-8)  summary(result4c) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7438  0.7910  0.8848  1.0000  1.2455  1.4923 data.frame(true = quants_known$x,             est = weightedQuantile(df_resp$x, result2$g*df_resp$d, probs),            est_el0 = weightedQuantile(df_resp$x, result4c*df_resp$d, probs),            est_el1 = weightedQuantile(df_resp$x, result4a$g*df_resp$d, probs),            est_el2 = weightedQuantile(df_resp$x, result4b$g*df_resp$d, probs)) #>          true       est   est_el0   est_el1   est_el2 #> 10%  7.078067  7.085003  3.640246  7.085003  7.085003 #> 20% 14.831221 14.824424  8.024948 14.824424 14.824424 #> 30% 23.146180 23.287657 14.499018 23.287657 23.287657 #> 40% 31.641911 31.802986 24.010501 31.802986 31.802986 #> 50% 39.033812 39.154276 39.154276 38.892342 39.154276 #> 60% 47.527168 48.252065 54.685438 48.252065 48.252065 #> 70% 54.984229 55.311953 63.084405 54.954054 54.954054 #> 80% 64.073167 64.062629 70.050593 64.062629 64.062629 #> 90% 71.565441 71.567274 75.663078 71.567274 71.567274 result5 <- joint_calib(formula_quantiles = ~ x,                         data = df_resp,                         dweights = df_resp$d,                         N = N,                         pop_quantiles = quants_known,                         method = \"eb\") summary(result5$g) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.4576  0.6775  0.8180  1.0003  1.4500  2.4538 results_y <- data.frame(true_y = y_quant_true,                         est_y1 = weightedQuantile(df_resp$y, result1$g * df_resp$d, probs),                         est_y2 = weightedQuantile(df_resp$y, result2$g * df_resp$d, probs),                         est_y3 = weightedQuantile(df_resp$y, result3$g * df_resp$d, probs),                         est_y4 = weightedQuantile(df_resp$y, result4c * df_resp$d, probs),                         est_y5 = weightedQuantile(df_resp$y, result4a$g * df_resp$d, probs),                         est_y6 = weightedQuantile(df_resp$y, result4b$g * df_resp$d, probs),                         est_y7 = weightedQuantile(df_resp$y, result5$g * df_resp$d, probs))  results_y #>         true_y     est_y1     est_y2     est_y3     est_y4     est_y5 #> 10%  -56.97982  -36.18473  -36.18473  -36.18473 -149.00996  -36.18473 #> 20%  210.58301  228.75429  228.75429  228.75429   17.27107  228.75429 #> 30%  444.81652  413.22517  417.60155  413.22517  203.58302  413.22517 #> 40%  646.06099  622.82192  622.82192  622.82192  381.99560  622.82192 #> 50%  803.50842  789.89936  789.89936  789.89936  503.35849  789.89936 #> 60%  975.31803  925.84730  925.84730  925.84730  679.04530  925.84730 #> 70% 1123.44643 1023.75230 1023.75230 1023.75230  811.84389 1023.75230 #> 80% 1245.62645 1162.06504 1162.06504 1162.06504 1009.46703 1162.06504 #> 90% 1449.23819 1471.33301 1471.33301 1471.33301 1242.60357 1471.33301 #>         est_y6     est_y7 #> 10%  -36.18473  -36.18473 #> 20%  228.75429  228.75429 #> 30%  411.47088  413.22517 #> 40%  622.82192  622.82192 #> 50%  789.89936  789.89936 #> 60%  925.84730  925.84730 #> 70% 1023.75230 1023.75230 #> 80% 1162.06504 1162.06504 #> 90% 1471.33301 1471.33301 apply(results_y[, -1], 2, FUN = function(x) sum((x-results_y[,1])^2)) #>    est_y1    est_y2    est_y3    est_y4    est_y5    est_y6    est_y7  #>  22342.87  22085.51  22342.87 547195.99  22342.87  22456.79  22342.87"},{"path":"https://ncn-foreigners.github.io/jointCalib/index.html","id":"using-survey-package","dir":"","previous_headings":"Examples","what":"Using survey package","title":"A Joint Calibration of Totals and Quantiles","text":"example 1a: calibrate quantiles (deciles) Calibration using calibrate Calibration using grake (low level)","code":"A <- joint_calib_create_matrix(X_q = model.matrix(~x+0, df_resp), N = N, pop_quantiles = quants_known) colnames(A) <- paste0(\"quant_\", gsub(\"\\\\D\", \"\", names(quants_known$x))) A <- as.data.frame(A) df_resp <- cbind(df_resp, A) head(df_resp) #>           x        y p        d quant_10 quant_20 quant_30 quant_40 quant_50 #> 6  12.35687 444.9053 1 3.134796        0    0.001    0.001    0.001    0.001 #> 7  61.90319 403.9473 1 3.134796        0    0.000    0.000    0.000    0.000 #> 13 60.96079 923.4975 1 3.134796        0    0.000    0.000    0.000    0.000 #> 14 76.85300 124.4110 1 3.134796        0    0.000    0.000    0.000    0.000 #> 18 71.52828 422.0934 1 3.134796        0    0.000    0.000    0.000    0.000 #> 19 65.32808 740.4801 1 3.134796        0    0.000    0.000    0.000    0.000 #>    quant_60 quant_70 quant_80 quant_90 #> 6     0.001    0.001    0.001    0.001 #> 7     0.000    0.000    0.001    0.001 #> 13    0.000    0.000    0.001    0.001 #> 14    0.000    0.000    0.000    0.000 #> 18    0.000    0.000    0.000    0.001 #> 19    0.000    0.000    0.000    0.001 m1 <- svydesign(ids = ~1, data = df_resp, weights = ~d) quants_formula <- as.formula(paste(\"~\", paste(colnames(A), collapse = \"+\"))) quants_formula #> ~quant_10 + quant_20 + quant_30 + quant_40 + quant_50 + quant_60 +  #>     quant_70 + quant_80 + quant_90 svytotal(quants_formula, m1) #>            total     SE #> quant_10 0.10972 0.0175 #> quant_20 0.23197 0.0237 #> quant_30 0.29154 0.0255 #> quant_40 0.34796 0.0267 #> quant_50 0.38871 0.0273 #> quant_60 0.43887 0.0278 #> quant_70 0.50784 0.0280 #> quant_80 0.63323 0.0270 #> quant_90 0.78100 0.0232 pop_totals <- c(N, probs) names(pop_totals) <- c(\"(Intercept)\", colnames(A)) m1_cal <- calibrate(m1, quants_formula, pop_totals) svytotal(quants_formula, m1_cal) #>          total SE #> quant_10   0.1  0 #> quant_20   0.2  0 #> quant_30   0.3  0 #> quant_40   0.4  0 #> quant_50   0.5  0 #> quant_60   0.6  0 #> quant_70   0.7  0 #> quant_80   0.8  0 #> quant_90   0.9  0 g1 <- grake(mm = as.matrix(cbind(1, A)),             ww = df_resp$d,             calfun = cal.linear,             population = pop_totals,             bounds = list(lower = -Inf, upper = Inf),             epsilon = 1e-7,             verbose = FALSE,             maxit = 50,             variance = NULL) summary(as.numeric(g1)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.4562  0.6773  0.8180  1.0000  1.4500  2.4538"},{"path":[]},{"path":[]},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal function for calibration of weights using empirical likelihood method — calib_el","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"calib_el performs calibration using empirical likelihood (EL) method. function taken Wu (2005). algorithm problem convergence constrOptim used instead (Zhang, Han Wu (2022)). (pseudo) EL following (pseudo) EL function maximized \\[\\sum_{\\r} d_i\\log(p_i),\\] following constraint \\[\\sum_{\\r} p_i = 1,\\] constraints quantiles (notation Harms Duchesne (2006)) \\[\\sum_{\\r} p_i(a_{} - \\alpha/N) = 0,\\] \\(a_{}\\) created using joint_calib_create_matrix function, possibly means \\[\\sum_{\\r} p_i(x_{} - \\mu_{x}) = 0,\\] \\(\\mu_{x}\\) known population mean X. simplicity notation assume one quantile one mean known. can generalized multiple quantiles means.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"","code":"calib_el(X, d, totals, maxit = 50, tol = 1e-08, eps = .Machine$double.eps, ...)"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"X matrix variables calibration quantiles totals (first column intercept), d initial d-weights calibration (e.g. design-weights), totals vector totals (1 element population size), maxit numeric value giving maximum number iterations, tol desired accuracy iterative procedure, eps desired accuracy computing Moore-Penrose generalized inverse (see MASS::ginv()), ... arguments passed stats::optim via stats::constrOptim.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"Returns vector empirical likelihood g-weights","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"Wu, C. (2005). Algorithms R codes pseudo empirical likelihood method survey sampling. Survey Methodology, 31(2), 239 (code taken https://sas.uwaterloo.ca/~cbwu/Rcodes/LagrangeM2.txt). Zhang, S., Han, P., Wu, C. (2023) Calibration Techniques Encompassing Survey Sampling, Missing Data Analysis Causal Inference. International Statistical Review, 91: 165–192. https://doi.org/10.1111/insr.12518 (code taken Supplementary Materials).","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"Maciej Beręsewicz based Wu (2005) Zhang, Han Wu (2022)","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/calib_el.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An internal function for calibration of weights using empirical likelihood method — calib_el","text":"","code":"## generate data based on Haziza and Lesage (2016) set.seed(123) N <- 1000 x <- runif(N, 0, 80) y <- exp(-0.1 + 0.1*x) + rnorm(N, 0, 300) p <- rbinom(N, 1, prob = exp(-0.2 - 0.014*x)) totals_known <- c(N=N, x=sum(x)) df <- data.frame(x, y, p) df_resp <- df[df$p == 1, ] df_resp$d <- N/nrow(df_resp) res <- calib_el(X = model.matrix(~x, df_resp),                 d = df_resp$d,                 totals = totals_known) data.frame(known = totals_known, estimated=colSums(res*df_resp$d*model.matrix(~x, df_resp))) #>      known estimated #> N  1000.00   1000.00 #> x 39782.22  39782.22"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/control_calib.html","id":null,"dir":"Reference","previous_headings":"","what":"control parameters — control_calib","title":"control parameters — control_calib","text":"control_calib function contains control parameters joint_calib_create_matrix","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/control_calib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"control parameters — control_calib","text":"","code":"control_calib(   interpolation = c(\"logit\", \"linear\"),   logit_const = -1000,   survey_sparse = FALSE,   ebal_constraint_tolerance = 1,   ebal_print_level = 0 )"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/control_calib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"control parameters — control_calib","text":"interpolation type interpolation: logit linear, logit_const constant logit interpolation, survey_sparse whether use sparse matrices via Matrix package survey::grake() (currently supported), ebal_constraint_tolerance tolerance level used ebalance decide moments reweighted data equal target moments (see ebal::ebalance()), ebal_print_level Controls level printing: 0 (normal printing), 2 (detailed), 3 (detailed) (see ebal::ebalance()).","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/control_calib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"control parameters — control_calib","text":"list parameters","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/control_calib.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"control parameters — control_calib","text":"Maciej Beręsewicz","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for the joint calibration of totals and quantiles — joint_calib","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"joint_calib allows joint calibration totals quantiles. provides user-friendly interface includes specification variables formula notation, vector population totals, list quantiles, variety backends methods.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"","code":"joint_calib(   formula_totals = NULL,   formula_quantiles = NULL,   data = NULL,   dweights = NULL,   N = NULL,   pop_totals = NULL,   pop_quantiles = NULL,   subset = NULL,   backend = c(\"sampling\", \"laeken\", \"survey\", \"ebal\", \"base\"),   method = c(\"raking\", \"linear\", \"logit\", \"sinh\", \"truncated\", \"el\", \"eb\"),   bounds = c(0, 10),   maxit = 50,   tol = 1e-08,   eps = .Machine$double.eps,   control = control_calib(),   ... )"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"formula_totals formula variables calibrate totals, formula_quantiles formula variables quantile calibration, data data.frame variables, dweights initial d-weights calibration (e.g. design weights), N population size calibration quantiles, pop_totals named vector population totals formula_totals. provided exactly survey package (see survey::calibrate), pop_quantiles named list population quantiles formula_quantiles newsvyquantile class object (survey::svyquantile function), subset formula subset data, backend specify R package perform calibration. sampling, laeken, survey, ebal base allowed, method specify method (.e. distance function) calibration. raking, linear, logit, sinh, truncated, el (empirical likelihood), eb (entropy balancing) allowed, bounds numeric vector length two giving bounds g-weights, maxit numeric value representing maximum number iterations, tol desired accuracy iterative procedure (sampling, laeken, ebal, el) tolerance matching population total survey::grake (see help survey::grake) eps desired accuracy computing Moore-Penrose generalized inverse (see MASS::ginv()) control list control parameters (currently joint_calib_create_matrix) ... arguments passed either sampling::calib, laeken::calibWeights, survey::calibrate optim::constrOptim","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"Returns list containing: g -- g-weight sums sample size, Xs -- matrix used calibration (.e. Intercept, X X_q transformed calibration quantiles), totals -- vector totals (.e. N, pop_totals pop_quantiles), method -- selected method, backend -- selected backend.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"Beręsewicz,  M., Szymkowiak, M. (2023). note joint calibration estimators totals quantiles Arxiv preprint https://arxiv.org/abs/2308.13281 Deville, J. C., Särndal, C. E. (1992). Calibration estimators survey sampling. Journal American statistical Association, 87(418), 376-382. Harms, T. Duchesne, P. (2006). calibration estimation quantiles. Survey Methodology, 32(1), 37. Wu, C. (2005) Algorithms R codes pseudo empirical likelihood method survey sampling, Survey Methodology, 31(2), 239. Zhang, S., Han, P., Wu, C. (2023) Calibration Techniques Encompassing Survey Sampling, Missing Data Analysis Causal Inference, International Statistical Review 91, 165–192. Haziza, D., Lesage, É. (2016). discussion weighting procedures unit nonresponse. Journal Official Statistics, 32(1), 129-145.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"Maciej Beręsewicz","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function for the joint calibration of totals and quantiles — joint_calib","text":"","code":"## generate data based on Haziza and Lesage (2016) set.seed(123) N <- 1000 x <- runif(N, 0, 80) y <- exp(-0.1 + 0.1*x) + rnorm(N, 0, 300) p <- rbinom(N, 1, prob = exp(-0.2 - 0.014*x)) probs <- seq(0.1, 0.9, 0.1) quants_known <- list(x=quantile(x, probs)) totals_known <- c(x=sum(x)) df <- data.frame(x, y, p) df_resp <- df[df$p == 1, ] df_resp$d <- N/nrow(df_resp) y_quant_true <- quantile(y, probs) ## standard calibration for comparison result0 <- sampling::calib(Xs = cbind(1, df_resp$x),                            d = df_resp$d,                            total = c(N, totals_known),                            method = \"linear\")  y_quant_hat0 <- laeken::weightedQuantile(x = df_resp$y,                                          probs = probs,                                          weights = result0*df_resp$d) x_quant_hat0 <- laeken::weightedQuantile(x = df_resp$x,                                          probs = probs,                                          weights = result0*df_resp$d)  ## example 1: calibrate only quantiles (deciles) result1 <- joint_calib(formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        method = \"linear\",                        backend = \"sampling\") ## estimate quantiles y_quant_hat1 <- laeken::weightedQuantile(x = df_resp$y,                                          probs = probs,                                          weights = result1$g*df_resp$d) x_quant_hat1 <- laeken::weightedQuantile(x = df_resp$x,                                          probs = probs,                                          weights = result1$g*df_resp$d)  ## compare with known data.frame(standard = y_quant_hat0, est=y_quant_hat1, true=y_quant_true) #>      standard        est       true #> 10% -284.3574 -285.34675 -292.97255 #> 20% -131.7079 -131.70792 -128.19010 #> 30%  -25.2815  -19.50460  -10.07312 #> 40%   80.5919   84.23786   84.64057 #> 50%  175.5490  178.96015  184.87445 #> 60%  274.0404  279.73343  294.76788 #> 70%  412.2826  426.98679  453.35435 #> 80%  592.0840  606.73082  669.36570 #> 90% 1105.6883 1172.38891 1163.92646  ## example 2: calibrate with quantiles (deciles) and totals result2 <- joint_calib(formula_totals = ~x,                        formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        pop_totals = totals_known,                        method = \"linear\",                        backend = \"sampling\") ## estimate quantiles y_quant_hat2 <- laeken::weightedQuantile(x = df_resp$y,                                          probs = probs,                                          weights = result2$g*df_resp$d) x_quant_hat2 <- laeken::weightedQuantile(x = df_resp$x,                                          probs = probs,                                          weights = result2$g*df_resp$d)  ## compare with known data.frame(standard = y_quant_hat0, est1=y_quant_hat1,            est2=y_quant_hat2, true=y_quant_true) #>      standard       est1       est2       true #> 10% -284.3574 -285.34675 -285.34675 -292.97255 #> 20% -131.7079 -131.70792 -131.70792 -128.19010 #> 30%  -25.2815  -19.50460  -21.94192  -10.07312 #> 40%   80.5919   84.23786   84.23786   84.64057 #> 50%  175.5490  178.96015  178.96015  184.87445 #> 60%  274.0404  279.73343  279.73343  294.76788 #> 70%  412.2826  426.98679  426.98679  453.35435 #> 80%  592.0840  606.73082  606.73082  669.36570 #> 90% 1105.6883 1172.38891 1172.38891 1163.92646  ## example 3: calibrate wigh quantiles (deciles) and totals with ## hyperbolic sinus (sinh) and survey package  result3 <- joint_calib(formula_totals = ~x,                        formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        pop_totals = totals_known,                        method = \"sinh\",                        backend = \"survey\")  ## estimate quantiles y_quant_hat3 <- laeken::weightedQuantile(x = df_resp$y,                                          probs = probs,                                          weights = result3$g*df_resp$d) x_quant_hat3 <- laeken::weightedQuantile(x = df_resp$x,                                          probs = probs,                                          weights = result3$g*df_resp$d)  ## example 4: calibrate wigh quantiles (deciles) and totals with ebal package result4 <- joint_calib(formula_totals = ~x,                        formula_quantiles = ~x,                        data = df_resp,                        dweights = df_resp$d,                        N = N,                        pop_quantiles = quants_known,                        pop_totals = totals_known,                        method = \"eb\",                        backend = \"ebal\")  ## estimate quantiles y_quant_hat4 <- laeken::weightedQuantile(x = df_resp$y,                                          probs = probs,                                          weights = result4$g*df_resp$d) x_quant_hat4 <- laeken::weightedQuantile(x = df_resp$x,                                          probs = probs,                                          weights = result4$g*df_resp$d)  ## compare with known data.frame(standard = y_quant_hat0,            est1=y_quant_hat1,            est2=y_quant_hat2,            est3=y_quant_hat3,            est4=y_quant_hat4,            true=y_quant_true) #>      standard       est1       est2       est3       est4       true #> 10% -284.3574 -285.34675 -285.34675 -285.34675 -285.34675 -292.97255 #> 20% -131.7079 -131.70792 -131.70792 -131.70792 -131.70792 -128.19010 #> 30%  -25.2815  -19.50460  -21.94192  -21.94192  -21.94192  -10.07312 #> 40%   80.5919   84.23786   84.23786   84.23786   84.23786   84.64057 #> 50%  175.5490  178.96015  178.96015  178.96015  178.96015  184.87445 #> 60%  274.0404  279.73343  279.73343  279.73343  279.73343  294.76788 #> 70%  412.2826  426.98679  426.98679  426.98679  426.98679  453.35435 #> 80%  592.0840  606.73082  606.73082  606.73082  606.73082  669.36570 #> 90% 1105.6883 1172.38891 1172.38891 1172.38891 1172.38891 1163.92646 ## compare with known X data.frame(standard = x_quant_hat0,            est1=x_quant_hat1,            est2=x_quant_hat2,            est3=x_quant_hat3,            est4=x_quant_hat4,            true = quants_known$x) #>     standard     est1     est2     est3     est4      true #> 10%  8.43342  8.08468  8.08468  8.08468  8.08468  8.081984 #> 20% 17.37948 16.27337 16.27337 16.27337 16.15962 16.250618 #> 30% 24.62111 24.32420 24.32420 24.09831 24.09831 24.231978 #> 40% 32.71552 31.67142 31.67142 31.67142 31.65285 31.663990 #> 50% 39.54339 39.18696 39.18696 39.18696 39.18696 39.196020 #> 60% 47.19213 47.53136 47.53136 47.44365 47.44365 47.469023 #> 70% 54.91923 55.60166 55.60166 55.45591 55.45591 55.499635 #> 80% 60.96227 63.90653 63.90653 63.90653 63.90653 63.906013 #> 90% 70.81061 71.60363 71.60363 71.12172 71.12172 71.338558"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"joint_calib_create_matrix function creates \\(= [a_{ij}]\\) matrix calibration quantiles. Function allows create matrix using logistic interpolation (using stats::plogis, default) linear (Harms Duchesne (2006), .e. slightly modified Heavyside function). case logistic interpolation elements \\(\\) created follows \\[a_{j} = \\frac{1}{(1 + \\exp\\left(-2l\\left(x_{ij}-Q_{x_j, \\alpha}\\right)\\right))N},\\] \\(x_{ij}\\) \\(\\)th row auxiliary variable \\(X_j\\), \\(N\\) population size, \\(Q_{x_j, \\alpha}\\) known population \\(\\alpha\\)th quantile, \\(l\\) set -1000 (default). case  linear interpolation elements \\(\\) created follows \\[a_{j}= \\begin{cases} N^{-1}, &  x_{j} \\leqslant L_{x_{j}, r} \\left(Q_{x_j, \\alpha}\\right), \\cr N^{-1} \\beta_{x_{j}, r}\\left(Q_{x_j, \\alpha}\\right), & x_{j}=U_{x_{j}, r}\\left(Q_{x_j, \\alpha}\\right), \\cr 0, & x_{j}>U_{x_{j}, r} \\left(Q_{x_j, \\alpha}\\right), \\end{cases}\\] \\(=1,...,r\\), \\(j=1,...,k\\), \\(r\\) set respondents, \\(k\\) auxiliary variable index \\[L_{x_{j}, r}(t) = \\max \\left\\lbrace\\left\\lbrace{x_{j}}, \\s \\mid x_{j} \\leqslant t\\right\\rbrace \\cup \\lbrace-\\infty\\rbrace \\right\\rbrace,\\] \\[U_{x_{j}, r}(t) = \\min \\left\\lbrace\\left\\lbrace{x_{j}}, \\s \\mid x_{j}>t\\right\\rbrace \\cup \\lbrace\\infty\\rbrace \\right\\rbrace,\\] \\[\\beta_{x_{j}, r}(t) = \\frac{t-L_{x_{j}, s}(t)}{U_{x_{j}, s}(t)-L_{x_{j}, s}(t)},\\] \\(=1,...,r\\), \\(j=1,...,k\\), \\(t \\\\mathbb{R}\\).","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"","code":"joint_calib_create_matrix(X_q, N, pop_quantiles, control = control_calib())"},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"X_q matrix variables calibration quantiles, N population size calibration quantiles, pop_quantiles vector population quantiles X_q, control control parameter creation X_q matrix.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"Return matrix ","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"Harms, T. Duchesne, P. (2006). calibration estimation quantiles. Survey Methodology, 32(1), 37.","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"Maciej Beręsewicz","code":""},{"path":"https://ncn-foreigners.github.io/jointCalib/reference/joint_calib_create_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An internal function to create an A matrix for calibration of quantiles — joint_calib_create_matrix","text":"","code":"# Create matrix for one variable and 3 quantiles set.seed(123) N <- 1000 x <- as.matrix(rnorm(N)) quants <- list(quantile(x, c(0.25,0.5,0.75))) A <- joint_calib_create_matrix(x, N, quants) head(A) #>               [,1]         [,2]  [,3] #> [1,]  3.417662e-33 1.000000e-03 0.001 #> [2,] 1.221974e-176 1.000000e-03 0.001 #> [3,]  0.000000e+00 0.000000e+00 0.000 #> [4,] 3.168423e-307 2.389406e-30 0.001 #> [5,]  0.000000e+00 7.091618e-56 0.001 #> [6,]  0.000000e+00 0.000000e+00 0.000 colSums(A) #> [1] 0.2502323 0.4999654 0.7498815  # Create matrix with linear interpolation A <- joint_calib_create_matrix(x, N, quants, control_calib(interpolation=\"linear\")) head(A) #>      [,1]  [,2]  [,3] #> [1,]    0 0.001 0.001 #> [2,]    0 0.001 0.001 #> [3,]    0 0.000 0.000 #> [4,]    0 0.000 0.001 #> [5,]    0 0.000 0.001 #> [6,]    0 0.000 0.000 colSums(A) #> [1] 0.24975 0.49950 0.74925  # Create matrix for two variables and different number of quantiles  set.seed(123) x1 <- rnorm(N) x2 <- rchisq(N, 1) x <- cbind(x1, x2) quants <- list(quantile(x1, 0.5), quantile(x2, c(0.1, 0.75, 0.9))) B <- joint_calib_create_matrix(x, N, quants) head(B) #>              [,1]          [,2]          [,3]  [,4] #> [1,] 1.000000e-03  7.889542e-30  1.000000e-03 0.001 #> [2,] 1.000000e-03 1.614292e-242  1.000000e-03 0.001 #> [3,] 0.000000e+00  0.000000e+00  0.000000e+00 0.001 #> [4,] 2.389406e-30  0.000000e+00  0.000000e+00 0.000 #> [5,] 7.091618e-56  0.000000e+00 1.360616e-132 0.001 #> [6,] 0.000000e+00  0.000000e+00  1.000000e-03 0.001 colSums(B) #> [1] 0.49996541 0.09961593 0.74980652 0.89987264"}]
