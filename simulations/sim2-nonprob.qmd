---
title: "Simulation 2 - non-probability sample"
format: 
  html:
    self-contained: true
    table-of-contents: true
    number-sections: true
    df-print: kable
editor: source
execute: 
  eval: true
  warning: false
  message: false
toc-title: Contents
lang: en
---


# Libraries and functions

Load libraries and functions 

```{r}
library(sampling)
library(laeken)
library(survey)
library(data.table)
library(ggplot2)
library(scales)
library(Rcpp)
library(nonprobsvy)
library(xtable)
source("../functions.R") ## to be replaced by package
```

PPS sampling function

```{r}
sourceCpp("syspps.cpp")
```


# Simulate data

+ population size $N=20,000$
+ probability sample $B$ is of size $1000$
+ non-probability sample $A$ is of size $1000$
+ auxiliary variables $x$ are generated as follows:
  + $z_{1 i} \sim \operatorname{Bernoulli}(0.5)$
  + $z_{2 i} \sim \operatorname{Uniform}(0,2)$
  + $z_{3 i} \sim \operatorname{Exponential}(1)$
  + $z_{4 i} \sim \chi^{2}(4)$
  + $x_{1 i}=z_{1i}$
  + $x_{2 i}=z_{2 i}+0.3 x_{1 i}$
  + $x_{3 i}=z_{3 i}+0.2(x_{1 i}+x_{2 i})$
  + $x_{4 i}=z_{4 i}+0.1(x_{1 i}+x_{2 i}+x_{3 i})$
+ target varible $y$ is generated using the following linear model

$$
y_{i}=2+x_{1 i}+x_{2 i}+x_{3 i}+x_{4 i}+\sigma \varepsilon_{i}, \quad i=1,2, \ldots, N
$$

where $\varepsilon_{i}$ 's are independent and identically
distributed (iid) as $N(0,1)$,

+ values of $\sigma$ chosen such that the correlation coefficient $\rho$ between $y$ and the linear predictor $\boldsymbol{x}^{\top} \boldsymbol{\beta}$ is controlled at $0.3, 0.5$ and $0.8$
+ The true propensity scores
$\pi_{i}^A$ for the non-probability sample $A$ follow the logistic regression model: 

$$
\log (\frac{\pi_{i}^{\mathrm{A}}}{1-\pi_{i}^{\mathrm{A}}})=\theta_{0}+0.1 x_{1 i}+0.2 x_{2 i}+0.1 x_{3 i}+0.2 x_{4 i}
$$

where $\theta_{0}$ is chosen such that $\sum_{i=1}^{N} \pi_{i}^{\mathrm{A}}=n_{\mathrm{A}}$ with the given
target sample size $n_{\mathrm{A}}$. 
 
+ The nonprobability sample $A$ is selected by the Poisson sampling method with inclusion probabilities specified by $\pi_{i}^A$ and the target sample size $n_A$.

+ The probability sample $B$ with the target size $n_B$ is taken by the randomized systematic PPS sampling method with the inclusion probabilities $\pi_{i}^B$ proportional to $z_{i}=c+x_{3 i}$. The value of $c$ is chosen to control the variation of the survey weights such that $\max z_{i} / \min z_{i}=50$.

Design:

1. known population totals and quantiles 
2. estimated population totals and quantiles

```{r}
seed_for_sim <- 2023-07-14
```

```{r sim-data}
set.seed(seed_for_sim+1)
N <- 20000
n_1 <- 1000
n_2 <- 1000
z1 <- rbinom(N, 1, 0.5)
z2 <- runif(N,0,2)
z3 <- rexp(N,1)
z4 <- rchisq(N, 4)
x1 <- z1
x2 <- z2 + 0.3*z1
x3 <- z3 + 0.2*(x1 + x2)
x4 <- z4 + 0.1*(x1 + x2 + x3)
e <- rnorm(N)

etol <- 1e-8
sigma03 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.3, c(0,20), tol = etol)$root
sigma05 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.5, c(0,20), tol = etol)$root
sigma08 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.8, c(0,20), tol = etol)$root

y1 <- 2+x1+x2+x3+x4+sigma03*e
y2 <- 2+x1+x2+x3+x4+sigma05*e
y3 <- 2+x1+x2+x3+x4+sigma08*e

theta_A1 <- stats::uniroot(f = function(s) sum(plogis(s + 0.1*x1+0.2*x2+0.3*x3+0.2*x4))-n_1, c(-20,0), tol = etol)$root

pA_1 <- plogis(theta_A1 + 0.1*x1+0.2*x2+0.3*x3+0.2*x4)
w_pA_1 <- 1/pA_1

s_B <- stats::uniroot(f = function(s) max(s+x3)/min(s+x3) - 50, c(0, 100), tol = etol)$root
pB_1 <- inclusionprobabilities(s_B + x3, n_1)
pB_2 <- inclusionprobabilities(s_B + x3, n_2)
w_pB_1 <- 1/pB_1
w_pB_2 <- 1/pB_2

pop_data <- data.frame(x1,x2,x3,x4,y1,y2,y3,pA_1,pA_2,w_pA_1,w_pA_2,pB_1,pB_2,w_pB_1,w_pB_2) |> setDT()
head(pop_data)
```

# Simulation

## Known population totals and quantiles -- quartiles

```{r}
x_totals <- with(pop_data, c(sum(x1), sum(x2), sum(x3), sum(x4)))
p_quantiles_est <- seq(0.25, 0.75, 0.25) ## for estimation
#p_quantiles <- seq(0.1, 0.9, 0.1) ## for calibration
p_quantiles <- p_quantiles_est ## for calibration
x2_q <- with(pop_data, quantile(x2, p_quantiles))
x3_q <- with(pop_data, quantile(x3, p_quantiles))
x4_q <- with(pop_data, quantile(x4, p_quantiles))
k_quants <- NROW(p_quantiles)-1
k_quants_est <- NROW(p_quantiles_est)-1
```

```{r}
pop_true_vals <- pop_data[, lapply(.SD, 
                                   function(x) data.frame(m=mean(x), 
                                                          q25=quantile(x, 0.25), 
                                                          q50=quantile(x, 0.5), 
                                                          q75=quantile(x, 0.75))), 
                          .SDcols = c("y1", "y2", "y3")] |> 
  melt(value.name = "true") |> 
  {\(x) x[, c("y", "estimator") := tstrsplit(variable, "\\.")][, .(y, estimator, true)]}()

pop_true_vals[, estimator2:= factor(estimator, c("m", "q25", "q50", "q75"), c("Mean", "Q25", "Q50", "Q75"))]
```

## Estimated population totals and quantiles

```{r}
n_reps <- 1000
```


```{r}
results_y3_sample <- 
  results_y2_sample <- 
  results_y1_sample <- matrix(data=0, 
                              nrow = n_reps, 
                              ncol = (1+(k_quants_est+1))*4 + 1 + 3 + (k_quants_est+1)*2)
```


```{r sim-est-totals}
for (r in 1:n_reps) {
  set.seed(r)
  if (r %% 50 == 0) cat("Iteration: ", r, "\n")
  sample_nonprob <- pop_data[which(sampling::UPpoisson(pop_data$pA_1)==1),]
  sample_prob <- pop_data[syspps_cpp(pop_data$pB_1, n_1), ] 
  sample_nonprob$w_naive <- sum(1/sample_prob$pB_1)/n_1
  sample_prob_svy <- svydesign(ids=~1, probs =~pB_1, data = sample_prob)

  q_est <- svyquantile( ~ x2 + x3 + x4, sample_prob_svy, p_quantiles)
  x_totals <- svytotal( ~ x1 + x2 + x3 + x4, sample_prob_svy) |> as.numeric()
  N_hat <- sum(weights(sample_prob_svy))
  
  ipw_y1 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                    target = ~ y1,
                    svydesign = sample_prob_svy,
                    data = sample_nonprob)
  
  ipw_y2 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                    target = ~ y2,
                    svydesign = sample_prob_svy,
                    data = sample_nonprob)
  
  ipw_y3 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                    target = ~ y3,
                    svydesign = sample_prob_svy,
                    data = sample_nonprob)
   
  mi_y1 <- nonprob(outcome = y1 ~ x1 + x2 + x3 + x4,
                    svydesign = sample_prob_svy,
                    data = sample_nonprob)
  
  mi_y2 <- nonprob(outcome = y2 ~ x1 + x2 + x3 + x4,
                   svydesign = sample_prob_svy,
                   data = sample_nonprob)
    
  mi_y3 <- nonprob(outcome = y3 ~ x1 + x2 + x3 + x4,
                   svydesign = sample_prob_svy,
                   data = sample_nonprob)

  
  dr_y1 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                   outcome = y1 ~ x1 + x2 + x3 + x4,
                   svydesign = sample_prob_svy,
                   data = sample_nonprob)
  
  dr_y2 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                   outcome = y2 ~ x1 + x2 + x3 + x4,
                   svydesign = sample_prob_svy,
                   data = sample_nonprob)
  
  dr_y3 <- nonprob(selection = ~ x1 + x2 + x3 + x4,
                   outcome = y3 ~ x1 + x2 + x3 + x4,
                   svydesign = sample_prob_svy,
                   data = sample_nonprob)
    
  w_res <- calib_quantiles(X_q = with(sample_nonprob, cbind(x2, x3, x4)),  
                            d = sample_nonprob$w_naive,  
                            N=N_hat,  
                            totals_q = list(q_est$x2[, 1], q_est$x3[, 1], q_est$x4[, 1]), 
                            method = "raking",
                            backend = "sampling")


  w_res2 <- calib_quantiles(X_q = with(sample_nonprob, cbind(x2, x3, x4)),
                           X =  with(sample_nonprob, cbind(x1, x2, x3, x4)),
                           d = sample_nonprob$w_naive,
                           N=N_hat,
                           totals = x_totals,
                           totals_q = list(q_est$x2[, 1], q_est$x3[, 1], q_est$x4[, 1]),
                           method = "raking",
                           backend = "sampling")
  
  w_res_st <- calib(Xs = with(sample_nonprob, cbind(x1, x2, x3, x4)), 
                    d = sample_nonprob$w_naive, 
                    total = x_totals, 
                    method = "raking")
  
  sample_nonprob$w_cal_q1 <- w_res$w
  sample_nonprob$w_cal_q2 <- w_res2$w
  sample_nonprob$w_cal_s <- sample_nonprob$w_naive*w_res_st
  sample_nonprob$w_ipw <- ipw_y1$weights
  sample_nonprob$w_dr <- dr_y1$weights
  
  results_y1_sample[r, 1] <- r
  results_y1_sample[r, 2] <- with(sample_nonprob, mean(y1))
  results_y1_sample[r, 3] <- with(sample_nonprob, weighted.mean(y1, w_cal_s))
  results_y1_sample[r, 4] <- with(sample_nonprob, weighted.mean(y1, w_cal_q1))
  results_y1_sample[r, 5] <- with(sample_nonprob, weighted.mean(y1, w_cal_q2))
  results_y1_sample[r, 6] <- ipw_y1$output$mean
  results_y1_sample[r, 7] <- mi_y1$output$mean
  results_y1_sample[r, 8] <- dr_y1$output$mean
  results_y1_sample[r, 9:(9+k_quants_est)] <- with(sample_nonprob, quantile(y1, p_quantiles_est))
  results_y1_sample[r, (9+1*k_quants_est+1):(9+2*k_quants_est+1)] <- with(sample_nonprob, weightedQuantile(y1, w_ipw,p_quantiles_est))
  results_y1_sample[r, (9+2*k_quants_est+2):(9+3*k_quants_est+2)] <- with(sample_nonprob, weightedQuantile(y1, w_dr,p_quantiles_est))
  results_y1_sample[r, (9+3*k_quants_est+3):(9+4*k_quants_est+3)] <- with(sample_nonprob, weightedQuantile(y1, w_cal_s, p_quantiles_est))
  results_y1_sample[r, (9+4*k_quants_est+4):(9+5*k_quants_est+4)] <- with(sample_nonprob, weightedQuantile(y1, w_cal_q1, p_quantiles_est))
  results_y1_sample[r, (9+5*k_quants_est+5):(9+6*k_quants_est+5)] <- with(sample_nonprob, weightedQuantile(y1, w_cal_q2, p_quantiles_est))

  results_y2_sample[r, 1] <- r
  results_y2_sample[r, 2] <- with(sample_nonprob, mean(y2))
  results_y2_sample[r, 3] <- with(sample_nonprob, weighted.mean(y2, w_cal_s))
  results_y2_sample[r, 4] <- with(sample_nonprob, weighted.mean(y2, w_cal_q1))
  results_y2_sample[r, 5] <- with(sample_nonprob, weighted.mean(y2, w_cal_q2))
  results_y2_sample[r, 6] <- ipw_y2$output$mean
  results_y2_sample[r, 7] <- mi_y2$output$mean
  results_y2_sample[r, 8] <- dr_y2$output$mean
  results_y2_sample[r, 9:(9+k_quants_est)] <- with(sample_nonprob, quantile(y2, p_quantiles_est))
  results_y2_sample[r, (9+1*k_quants_est+1):(9+2*k_quants_est+1)] <- with(sample_nonprob, weightedQuantile(y2, w_ipw,p_quantiles_est))
  results_y2_sample[r, (9+2*k_quants_est+2):(9+3*k_quants_est+2)] <- with(sample_nonprob, weightedQuantile(y2, w_dr,p_quantiles_est))
  results_y2_sample[r, (9+3*k_quants_est+3):(9+4*k_quants_est+3)] <- with(sample_nonprob, weightedQuantile(y2, w_cal_s, p_quantiles_est))
  results_y2_sample[r, (9+4*k_quants_est+4):(9+5*k_quants_est+4)] <- with(sample_nonprob, weightedQuantile(y2, w_cal_q1, p_quantiles_est))
  results_y2_sample[r, (9+5*k_quants_est+5):(9+6*k_quants_est+5)] <- with(sample_nonprob, weightedQuantile(y2, w_cal_q2, p_quantiles_est))
  
  results_y3_sample[r, 1] <- r
  results_y3_sample[r, 2] <- with(sample_nonprob, mean(y3))
  results_y3_sample[r, 3] <- with(sample_nonprob, weighted.mean(y3, w_cal_s))
  results_y3_sample[r, 4] <- with(sample_nonprob, weighted.mean(y3, w_cal_q1))
  results_y3_sample[r, 5] <- with(sample_nonprob, weighted.mean(y3, w_cal_q2))
  results_y3_sample[r, 6] <- ipw_y3$output$mean
  results_y3_sample[r, 7] <- mi_y3$output$mean
  results_y3_sample[r, 8] <- dr_y3$output$mean
  results_y3_sample[r, 9:(9+k_quants_est)] <- with(sample_nonprob, quantile(y3, p_quantiles_est))
  results_y3_sample[r, (9+1*k_quants_est+1):(9+2*k_quants_est+1)] <- with(sample_nonprob, weightedQuantile(y3, w_ipw,p_quantiles_est))
  results_y3_sample[r, (9+2*k_quants_est+2):(9+3*k_quants_est+2)] <- with(sample_nonprob, weightedQuantile(y3, w_dr,p_quantiles_est))
  results_y3_sample[r, (9+3*k_quants_est+3):(9+4*k_quants_est+3)] <- with(sample_nonprob, weightedQuantile(y3, w_cal_s, p_quantiles_est))
  results_y3_sample[r, (9+4*k_quants_est+4):(9+5*k_quants_est+4)] <- with(sample_nonprob, weightedQuantile(y3, w_cal_q1, p_quantiles_est))
  results_y3_sample[r, (9+5*k_quants_est+5):(9+6*k_quants_est+5)] <- with(sample_nonprob, weightedQuantile(y3, w_cal_q2, p_quantiles_est))
  
}

```

Combine results

```{r}
results_sample <- rbind(results_y1_sample, results_y2_sample, results_y3_sample) |> as.data.frame() |> setDT()
setnames(results_sample, names(results_sample), 
         c("iter", "m_naive", "m_cal", "m_qcal1", "m_qcal2",
           "m_ipw", "m_mi", "m_dr",
           paste(paste0("q", rep(c(25, 50, 75), times = 4)), 
                 rep(c("naive", "cal", "ipw", "dr", "qcal1", "qcal2"), each = 3), sep="_")))

results_sample[, y:=rep(c("y1", "y2", "y3"), each = n_reps)]
results_sample <- melt(results_sample, id.vars = c("iter", "y"), value.name = "value", variable.name = "estimator") 
results_sample[, c("estimator", "type") := tstrsplit(estimator, "_")]
results_sample <- results_sample[pop_true_vals, on = c("y", "estimator")]
results_sample[, type:= factor(type, c("naive", "cal", "ipw", "mi", "dr", "qcal1", "qcal2"),
                                c("Naive", "Cal", "IPW", "MI", "DR", "QCal1", "QCal2"))]
results_sample[, estimator:= factor(estimator, c("m", "q25", "q50", "q75"), c("Mean", "Q25", "Q50", "Q75"))]


results_sample[estimator == "Mean"] |> 
  ggplot(data = _, aes(x = type, y = value)) +
  geom_jitter(alpha = 0.05, shape = 1) + 
  geom_violin(alpha = 0.8, draw_quantiles = c(0.25, 0.5, 0.75), scale = "width") + 
  stat_summary(fun = mean, geom = "point") + 
  facet_wrap(~y)  + 
    geom_hline(data = pop_true_vals[estimator2 == "Mean", .(y, estimator=estimator2, true)], 
             aes(yintercept = true), linetype = "dashed", color = "red") + 
  labs(x = "Estimator", y = "Value") -> p2

p2
ggsave(plot = p2, filename = "../figs/sim-nonprob-estimated-mean.pdf", width = 8, height = 6)
ggsave(plot = p2, filename = "../figs/sim-nonprob-estimated-mean.png", width = 8, height = 6)

results_sample[estimator != "Mean"] |> 
  ggplot(data = _, aes(x = type, y = value)) +
  geom_jitter(alpha = 0.05, shape = 1) + 
  geom_violin(alpha = 0.8, draw_quantiles = c(0.25, 0.5, 0.75), scale = "width") + 
  stat_summary(fun = mean, geom = "point") + 
  facet_grid(y ~ estimator, scales = "free_y")  + 
    geom_hline(data = pop_true_vals[estimator2 != "Mean", .(y, estimator=estimator2, true)], 
             aes(yintercept = true), linetype = "dashed", color = "red") + 
  labs(x = "Estimator", y = "Value") -> p2

p2
ggsave(plot = p2, filename = "../figs/sim-nonprob-estimated-quantiles.pdf", width = 8, height = 6)
ggsave(plot = p2, filename = "../figs/sim-nonprob-estimated-quantiles.png", width = 8, height = 6)

```

```{r}
results_sample[, .(mean = mean(value), bias=mean(value)-mean(true), var = var(value)), .(y, estimator, type)][
  , ":="(mse = bias^2+var, rmse = sqrt(bias^2+var))][order(y, estimator)][
    , .(y, 
        characteristic=estimator,
        estimator=type, 
        bias, var, rmse)] |> 
  melt(id.vars = c("y", "characteristic", "estimator")) |> 
  transform(y = paste(y, variable, sep = "_")) |> 
  transform(variable = NULL) |> 
  dcast(... ~ y, value.var = "value") |> 
  {\(x) x[, .(characteristic, estimator, y1_bias, y1_var, y1_rmse, y2_bias, y2_var, y2_rmse, y3_bias, y3_var, y3_rmse)]}() -> results_sim_estimated

results_sim_estimated[characteristic %in% c("Mean","Q50"), .(characteristic, estimator, y1_bias, y1_rmse)]
```

```{r}
results_sim_estimated |> 
  xtable() |> 
  print.xtable(include.rownames = F)
```

```{r}
saveRDS(results_sample, file = "../results/sim-chen2020-jasa.rds")
```


